import { Todo, Note } from '../models/index';
import type { TodoData, NoteData } from '../models/index';
import type { DataProviderAsync, DataProviderConfig, QueryOptions } from './types';

export class LocalStorageDataProvider implements DataProviderAsync {
    private readonly TODO_KEY = 'todos';
    private readonly NOTE_KEY = 'notes';
    private connected: boolean = false;

    constructor(_: DataProviderConfig) {
    }

    async connect(): Promise<void> {
        // For localStorage, connection is just verifying localStorage is available
        if (typeof window !== 'undefined' && window.localStorage) {
            this.connected = true;
            return;
        }
        throw new Error('LocalStorage is not available');
    }

    async disconnect(): Promise<void> {
        this.connected = false;
    }

    isConnected(): boolean {
        return this.connected;
    }

    private getFromStorage<T>(key: string): T[] {
        if (!this.isConnected()) {
            throw new Error('Data provider is not connected');
        }
        const data = localStorage.getItem(key);
        if (!data) {
            return [];
        }
        try {
            return JSON.parse(data);
        } catch (error) {
            console.warn(`Failed to parse localStorage data for key "${key}":`, error);
            return [];
        }
    }

    private saveToStorage<T>(key: string, data: T[]): void {
        if (!this.isConnected()) {
            throw new Error('Data provider is not connected');
        }
        localStorage.setItem(key, JSON.stringify(data));
    }

    async getTodos(queryOptions: QueryOptions = {}): Promise<Todo[]> {
        let todos = this.getFromStorage<TodoData>(this.TODO_KEY)
            .map(d => Todo.fromJSON(d));

        // Apply filters
        if (queryOptions.filters) {
            todos = todos.filter(todo => {
                return Object.entries(queryOptions.filters!).every(([key, value]) => {
                    if (key === 'date') {
                        return todo.date === value;
                    }
                    if (key === 'title') {
                        return todo.title.toLowerCase().includes((value as string).toLowerCase());
                    }
                    return true;
                });
            });
        }

        // Apply sorting
        if (queryOptions.orderBy) {
            todos.sort((a, b) => {
                const direction = queryOptions.orderDirection === 'desc' ? -1 : 1;
                if (queryOptions.orderBy === 'date') {
                    return (a.date > b.date ? 1 : -1) * direction;
                }
                if (queryOptions.orderBy === 'title') {
                    return a.title.localeCompare(b.title) * direction;
                }
                return 0;
            });
        }

        // Apply pagination
        const offset = queryOptions.offset || 0;
        const limit = queryOptions.limit || todos.length;
        return todos.slice(offset, offset + limit);
    }

    async getTodo(id: string): Promise<Todo | null> {
        const todos = this.getFromStorage<TodoData>('todos');
        const todoData = todos.find(t => t.id === id);
        return todoData ? new Todo(todoData) : null;
    }

    async createTodo(data: TodoData): Promise<Todo> {
        const todos = await this.getTodos();
        const todo = new Todo(data);
        todos.push(todo);
        this.saveToStorage(this.TODO_KEY, todos.map(t => t.toJSON()));
        return todo;
    }

    async updateTodo(id: string, data: Partial<TodoData>): Promise<Todo> {
        const todos = await this.getTodos();
        const todo = todos.find(t => t.id === id);
        if (!todo) {
            throw new Error(`Todo with id ${id} not found`);
        }
        todo.update(data);
        this.saveToStorage(this.TODO_KEY, todos.map(t => t.toJSON()));
        return todo;
    }

    async deleteTodo(id: string): Promise<void> {
        const todos = await this.getTodos();
        const filteredTodos = todos.filter(t => t.id !== id);
        this.saveToStorage(this.TODO_KEY, filteredTodos.map(t => t.toJSON()));
    }

    async moveTaskBetweenGroups(todoId: string, taskId: string, targetGroupId: string, targetIndex?: number): Promise<boolean> {
        const todos = await this.getTodos();
        const todo = todos.find(t => t.id === todoId);
        if (!todo) {
            throw new Error(`Todo with id ${todoId} not found`);
        }

        const result = todo.moveTaskBetweenGroups(taskId, targetGroupId, targetIndex);
        if (result) {
            this.saveToStorage(this.TODO_KEY, todos.map(t => t.toJSON()));
        }
        return result;
    }

    async reorderTasksInGroup(todoId: string, groupId: string, taskIds: string[]): Promise<void> {
        const todos = await this.getTodos();
        const todo = todos.find(t => t.id === todoId);
        if (!todo) {
            throw new Error(`Todo with id ${todoId} not found`);
        }

        const group = todo.findGroup(groupId);
        if (!group) {
            throw new Error(`Group with id ${groupId} not found`);
        }

        group.reorderTasks(taskIds);
        this.saveToStorage(this.TODO_KEY, todos.map(t => t.toJSON()));
    }

    async reorderGroupsInTodo(todoId: string, groupIds: string[]): Promise<void> {
        const todos = await this.getTodos();
        const todo = todos.find(t => t.id === todoId);
        if (!todo) {
            throw new Error(`Todo with id ${todoId} not found`);
        }

        todo.reorderGroups(groupIds);
        this.saveToStorage(this.TODO_KEY, todos.map(t => t.toJSON()));
    }

    async getNotes(queryOptions: QueryOptions = {}): Promise<Note[]> {
        let notes = await this.getFromStorage<NoteData>(this.NOTE_KEY).then(data => data.map(d => Note.fromJSON(d)));

        // Apply filters
        if (queryOptions.filters) {
            notes = notes.filter(note => {
                return Object.entries(queryOptions.filters!).every(([key, value]) => {
                    if (key === 'text') {
                        return note.text.toLowerCase().includes((value as string).toLowerCase());
                    }
                    if (key === 'color') {
                        return note.color === value;
                    }
                    if (key === 'tags') {
                        return Array.isArray(value) && value.every(v => note.tags.includes(v));
                    }
                    return true;
                });
            });
        }

        // Apply sorting
        if (queryOptions.orderBy) {
            notes.sort((a, b) => {
                const direction = queryOptions.orderDirection === 'desc' ? -1 : 1;
                if (queryOptions.orderBy === 'createdAt') {
                    return (a.createdAt > b.createdAt ? 1 : -1) * direction;
                }
                if (queryOptions.orderBy === 'text') {
                    return a.text.localeCompare(b.text) * direction;
                }
                return 0;
            });
        }

        // Apply pagination
        const offset = queryOptions.offset || 0;
        const limit = queryOptions.limit || notes.length;
        return notes.slice(offset, offset + limit);
    }

    async getNote(id: string): Promise<Note | null> {
        const notes = await this.getNotes();
        return notes.find(note => note.id === id) || null;
    }

    async createNote(data: NoteData): Promise<Note> {
        const notes = await this.getNotes();
        const note = new Note(data);
        notes.push(note);
        this.saveToStorage(this.NOTE_KEY, notes.map(n => n.toJSON()));
        return note;
    }

    async updateNote(id: string, data: Partial<NoteData>): Promise<Note> {
        const notes = await this.getNotes();
        const note = notes.find(n => n.id === id);
        if (!note) {
            throw new Error(`Note with id ${id} not found`);
        }
        note.update(data);
        this.saveToStorage(this.NOTE_KEY, notes.map(n => n.toJSON()));
        return note;
    }

    async deleteNote(id: string): Promise<void> {
        const notes = await this.getNotes();
        const filteredNotes = notes.filter(n => n.id !== id);
        this.saveToStorage(this.NOTE_KEY, filteredNotes.map(n => n.toJSON()));
    }

    async getAllData(): Promise<{
        todos: Todo[];
        notes: Note[];
    }> {
        return {
            todos: await this.getTodos(),
            notes: await this.getNotes()
        };
    }

    async clearAllData(): Promise<void> {
        if (!this.isConnected()) {
            throw new Error('Data provider is not connected');
        }
        localStorage.removeItem(this.TODO_KEY);
        localStorage.removeItem(this.NOTE_KEY);
    }
}

